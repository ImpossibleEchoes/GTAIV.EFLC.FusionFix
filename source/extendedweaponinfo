module;

#include <common.hxx>
#include <vector>
#include <string>

export module extendedweaponinfo;

import common;
import settings;

std::vector<uint32_t> g_names;
SafetyHookInline shGetWeaponInfoIdByHash = {};

int __cdecl getWeaponInfoIdByHash(int hash, int _default)
{
	// Call the original function. It will check if this weapon is vanilla
	int id = shGetWeaponInfoIdByHash.unsafe_ccall<int>(hash, -1);

	// -1 is a marker for the script, in case it's a new weapon.
	if (id != -1)
		return id;
	else if (_default == 55) // But if it's not a vanilla weapon and the second argument was 55(unk weapon), we don't add it
		return 55;

	// Let's check if this new weapon was added before
	for (size_t i = 0; i < g_names.size(); i++)
		if (g_names[i] == hash)
			return i + 58;

	// If it's not a vanilla weapon and the second argument isn't 55, then we add it
	_default = g_names.size() + 58;
	g_names.push_back(hash);

	return _default;

}

class ExtendedWeaponInfo
{
public:
	ExtendedWeaponInfo()
	{
		FusionFix::onInitEvent() += []()
			{
				CIniReader iniReader("");
				auto bExtendedLimits = iniReader.ReadInteger("BudgetedIV", "ExtendedLimits", 0);
				if (bExtendedLimits)
				{
					auto pattern = hook::pattern("C0 3B 0C 85 ? ? ? ? 74 0C ");
					if (pattern.empty())
						pattern = hook::pattern("C0 3B 0C 85 ? ? ? ? 74 0A 40 ");
					if (!pattern.empty())
						shGetWeaponInfoIdByHash = safetyhook::create_inline(pattern.get_first(5), getWeaponInfoIdByHash);

				}

			

			};
	}
} ExtendedWeaponInfo;
